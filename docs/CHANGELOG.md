# Changelog

All notable changes to this project will be documented in this file.

Format based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/).

## [Unreleased]

### Fixed
- F1 LatencySpike, F6 SlowLeak, F7 SplitBrain faults firing multiple times per game tick when called across zones. Added per-tick deduplication guard so global-once-per-tick faults (sleep, counter increment) execute exactly once regardless of zone count

### Added
- Configurable spawn duration: `s` key now opens a `DurationPickerScreen` modal with 10s, 30s, 60s, and persistent (until stopped) options. Replaces hardcoded 5-second spawn
- Graceful despawn keybinding (`k`): signals `threading.Event` to cleanly disconnect all running mock clients. Server sees clean TCP EOF → DISCONNECTED events
- `DURATION_OPTIONS` constant and `DurationPickerScreen` ModalScreen in `wowsim.dashboard`
- `stop_event: threading.Event | None` parameter on `MockGameClient.run()`, `_run_one()`, `spawn_clients()`, and `run_spawn()` — checked each loop iteration for cooperative cancellation. Supports `float('inf')` duration for persistent mode
- `spawn_active` parameter on `compute_suggestion()` — shows despawn guidance when clients are running
- `action_quit()` override signals stop_event before exit for clean shutdown with persistent clients
- Dashboard CSS for `DurationPickerScreen` and `#duration-options`
- 12 new pytest cases: stop_event early termination (4), spawn_active suggestion (3), despawn binding (2), duration picker (3). Total: 173 non-integration Python tests passing
- Interactive demo command (`wowsim demo`): single command that auto-detects the server binary, starts it as a subprocess, and launches an enhanced dashboard with guided suggestions. Suggestion bar adapts to state (spawn players → inject fault → observe → recover → pipeline → quit). Fault picker modal lists all 8 scenarios (F1-F8) with descriptions. Spawn clients (`s`), pipeline (`p`), and fault activation (`a`) keybindings use thread workers for Textual compatibility (ADR-029)
- `wowsim.demo_runner` module: testable pure functions for binary detection (`find_server_binary`), telemetry cleanup (`clean_telemetry`, `default_telemetry_path`), and `ServerProcess` class for subprocess lifecycle with readiness detection
- `FAULT_CATALOG` dict in `wowsim.dashboard`: all 8 fault scenarios with descriptions and default params, `format_fault_option` formatting helper
- `compute_suggestion` pure function: state-based decision tree returning context-aware guidance text for the suggestion bar
- `FaultPickerScreen` ModalScreen: OptionList of faults, selection activates, Escape cancels
- Dashboard keybindings: `s` (spawn 5 clients), `p` (run deployment pipeline), `a` (open fault picker modal) — complementing existing `r`/`d`/`x`/`q`
- 40 new pytest cases for dashboard (suggestion bar, spawn binding, fault catalog, pipeline binding) and demo_runner (binary detection, telemetry helpers, ServerProcess, CLI). Total: 158 non-integration Python tests passing
- Docker Compose one-command demo: `docker compose up --build` builds and runs the full 70-second reliability lifecycle automatically. Server-only mode available via `--profile server`. Dockerfile now includes `scripts/` directory. `demo.sh` gains Docker binary path detection (ADR-028)
- Polished README with skills mapping table, key features overview, inline Mermaid system-overview diagram, 4 sample terminal output blocks (healthy/critical health reports, anomaly detection, pipeline rollback), fault scenarios table (F1-F8), project stats, and 6 image placeholders with descriptive alt text. README is now a self-contained portfolio piece readable with or without captured screenshots
- `docs/assets/` directory for future screenshots and GIFs, with `.gitkeep`
- `docs/CAPTURE_GUIDE.md`: step-by-step instructions for recording 6 visual assets (2 GIFs, 4 PNGs) using asciinema/agg/gifsicle/pngquant, with per-asset commands, verification checks, and optimization tips
- Architecture diagrams in Mermaid (`docs/diagrams/`): 5 diagrams covering system overview, thread model, tick pipeline with fault injection points, session state machine, and Python tool composition. Linked from ARCHITECTURE.md with cross-references from inline ASCII diagrams and transition tables. GitHub renders Mermaid natively in markdown
- Demo walkthrough script (`scripts/demo.sh`): narrated, color-coded 6-phase bash script demonstrating the full server reliability lifecycle (baseline → break → diagnose → fix → pipeline → summary) in ~70 seconds. Composes all 5 Python CLI tools (spawn-clients, health, parse-logs, inject-fault, deploy) against the live C++ server. Cross-platform binary detection (Windows/Linux), TTY-safe ANSI colors, server lifecycle management with cleanup trap (ADR-027)
- Performance benchmark suite (`wowsim.benchmark`): automated scaling tests composing mock_client + health_check + percentile computation. Runs client count sweep (default 0/10/25/50/100), computes P50/P95/P99 tick durations via nearest-rank method, evaluates against configurable thresholds (avg ≤ 50ms, p99 ≤ 100ms, overrun ≤ 5%). Pure function core with thin I/O wrappers for monkeypatch-testable orchestration (ADR-026)
- `PercentileStats`, `ScenarioResult`, `BenchmarkConfig`, `BenchmarkResult` Pydantic v2 models in `wowsim.models` — percentile distributions, per-scenario outcomes, configurable thresholds, and full benchmark results with JSON serialization
- `benchmark` CLI command: `wowsim benchmark --log-file <path> --counts 0,10,25,50,100 --duration 10 --rate 2 --settle 2 --max-avg-tick 50 --max-p99-tick 100 --max-overrun-pct 5 --format text|json`. Exit code 0/1 for CI integration
- 20 pytest cases for benchmarks covering models (3), percentile computation (3), throughput (2), scenario evaluation (3), overall evaluation (2), formatting (2), orchestration (3), CLI (2). Total: 134 non-integration Python tests passing
- Advanced fault scenarios F5-F8 in `src/server/fault/scenarios.h/.cpp`:
  - F5 CascadingZoneFailureFault: crashes source zone via exception, floods target zone with synthetic events. Configurable source_zone, target_zone, flood_multiplier
  - F6 SlowLeakFault: incrementing tick processing delay over time. Configurable increment_ms, increment_every. `current_delay_ms()` accessor
  - F7 SplitBrainFault: phantom NPC entities with zone-dependent divergent positions. Configurable phantom_count, phantom_base_id
  - F8 ThunderingHerdFault: mass player disconnect then simultaneous reconnect after delay. Configurable reconnect_delay_ticks. NPCs preserved
- All F5-F8 faults registered in `main.cpp` — available via control channel at runtime (`wowsim inject-fault activate <id>`)
- 14 new GoogleTest cases for F5-F8 covering ID/mode, multi-phase behavior, zone interaction, and reset. Total: 264 C++ tests passing
- Hotfix deployment pipeline (`wowsim.pipeline`): staged build → validate → canary → promote/rollback lifecycle composing health_check and fault_trigger modules. Fault-as-deployment metaphor maps fault activation to deploy and deactivation to fix (ADR-024)
- `PipelineConfig`, `StageResult`, `PipelineResult` Pydantic v2 models in `wowsim.models` — configuration, per-stage outcomes, and full pipeline results with JSON serialization
- `deploy` CLI command: `wowsim deploy --fault-id <id> --action activate|deactivate` with canary duration/interval, rollback threshold, fault params, and text/json output
- Pure pipeline gate functions: `check_build_preconditions`, `check_validate_gate`, `evaluate_canary_health`, `determine_rollback_action`, `format_stage_result`, `format_pipeline_result` — independently testable without I/O
- Pipeline I/O wrappers composing `health_check.build_health_report()` and `fault_trigger.activate_fault()`/`deactivate_fault()` for mockable orchestration
- 20 pytest cases for pipeline covering models (3), gate functions (10), formatting (2), orchestration (3), CLI (2). Total: 130 Python tests passing
- Monitoring dashboard (`wowsim.dashboard`): Textual TUI with auto-refreshing status bar, tick metrics panel, zone health DataTable, fault control panel, and scrolling event log. Worker-thread health refresh for non-blocking sync I/O, async fault queries via ControlClient, timestamp watermark for duplicate-free event log updates (ADR-023)
- `DashboardConfig` Pydantic v2 model in `wowsim.dashboard` — configuration for log file path, server addresses, and refresh interval
- `dashboard` CLI command: `wowsim dashboard --log-file <path> --host <host> --port <port> --control-port <port> --refresh <seconds>`. Replaces placeholder stub
- Pure formatting functions in `wowsim.dashboard`: `format_status_bar`, `format_tick_panel`, `format_event_line`, `status_to_style`, `fault_action_label`, `filter_new_entries` — independently testable without Textual dependency
- Dashboard key bindings: `q` (quit), `r` (manual refresh), `a` (activate fault), `d` (deactivate fault), `x` (deactivate all faults)
- 16 pytest cases for dashboard covering formatting (9), entry filtering (3), config (2), CLI integration (2). Total: 110 Python tests passing
- Full `main.cpp` wiring: all subsystems connected end-to-end — Logger, ZoneManager (Elwynn Forest + Hogger, Westfall + Defias Pillager), FaultRegistry (F1-F4), SessionEventQueue, ControlChannel (port 8081), GameServer (port 8080), GameLoop (20 Hz on main thread). Server binary now runs, accepts connections, assigns players to zones, processes game ticks, handles fault injection commands, and shuts down gracefully on Ctrl+C
- `SessionEventQueue` (`wow::SessionEventQueue`): thread-safe queue bridging session lifecycle events (CONNECTED/DISCONNECTED) from GameServer's network thread to the game thread. Follows mutex + swap-drain pattern consistent with EventQueue and CommandQueue (ADR-022)
- `GameServer::set_session_event_queue()`: non-owning pointer to SessionEventQueue for connect/disconnect notifications. Null-safe when no queue is set
- Signal handling: `std::signal(SIGINT)` + `std::atomic<bool>` flag for graceful Ctrl+C shutdown. Game loop checks flag at tick start, triggers orderly teardown
- Round-robin zone assignment: odd session_id → zone 1 (Elwynn Forest), even → zone 2 (Westfall)
- Pre-tick hook wiring: FaultRegistry's `execute_pre_tick_faults()` fires inside each zone's exception guard
- 7 new GoogleTest cases: SessionEventQueue (4 — construction, push/drain, drain-clears, concurrent push) and GameServer session events (3 — connect notification, disconnect notification, null-queue safety). Total: 250 C++ tests passing
- Integration test infrastructure (`tests/python/integration/conftest.py`): telemetry line helpers and 6 scenario fixtures (normal operation, latency spike, session crash, zone crash, recovery arc, 50-player load) generating deterministic JSONL log files with 50ms tick-aligned timestamps
- 6 connection lifecycle integration tests: client-to-mock-server connections, telemetry parsing for connection/disconnect events, player count estimation, server reachability, spawn-telemetry reconciliation, and 50-client stress test (PRD criterion 1)
- 6 fault injection and recovery integration tests: activate + detect latency anomaly, deactivate + verify recovery, session crash disconnect anomalies, health status transitions (healthy → critical → healthy), zone crash detection in health report, and fault list/status/deactivate composition
- 4 end-to-end integration tests: full 5-tool pipeline (spawn → activate → detect → deactivate → recover), 50-player stress with health report validation (HEALTHY, 50 players, 0 overruns), all fault scenarios (F1-F4) produce detectable telemetry, and health report format completeness
- Full Python test suite: 78 existing + 16 integration = 94 tests passing
- Mock client spawner (`wowsim.mock_client`): async TCP client that generates WoW-realistic game traffic with weighted action selection (50% movement, 30% spell cast, 20% combat). Spawns N concurrent simulated players via `asyncio.gather` with per-client failure isolation. Payloads match C++ event types exactly for protocol groundwork (ADR-021)
- `ClientConfig`, `ClientResult`, `SpawnResult` Pydantic v2 models in `wowsim.models` — configuration, per-client outcomes, and aggregate spawn results with JSON serialization
- `spawn-clients` CLI command: `wowsim spawn-clients --count 10 --duration 60 --host localhost --port 8080 --rate 2 --format text|json`. Replaces placeholder stub
- Mock game server fixture (`mock_game_server`) in `tests/python/conftest.py` — ThreadingTCPServer on ephemeral port that accepts connections and discards data, tracking connection counts and bytes received
- 18 pytest cases for mock client covering models (3), traffic generation (3), action selection (2), single client lifecycle (3), multi-client spawning (3), formatting (2), CLI integration (2)
- Health check reporter (`wowsim.health_check`): aggregates server health from telemetry logs with pure computation functions for tick rate stats, zone health, player count estimation, and three-tier status determination (healthy/degraded/critical). Reuses `log_parser` anomaly detection and `fault_trigger` fault status queries (ADR-020)
- `TickHealth`, `ZoneHealthSummary`, `HealthReport` Pydantic v2 models in `wowsim.models` — composing existing `Anomaly` and `FaultInfo` models for complete health snapshots
- `health` CLI command: `wowsim health --log-file <path>` with `--watch`/`--interval` for continuous monitoring, `--format json|text` for output format, `--no-faults` to skip control channel queries, `--host`/`--port`/`--control-port` for server addresses
- Health check test fixtures (`health_log_entries`, `health_log_file`) in `tests/python/conftest.py` — 11 telemetry entries covering ticks, zones, errors, connections, and disconnections
- 20 pytest cases for health check covering models (3), tick health (3), zone health and player count (3), status determination (5), reachability (2), report building and formatting (2), CLI integration (2)
- Fault trigger client (`wowsim.fault_trigger`): async TCP client (`ControlClient`) for the C++ control channel with sync wrappers for CLI use. Pydantic v2 models for the control channel protocol (5 request types, `FaultInfo`, `ControlResponse`). Duration parsing (`5s` → 100 ticks, `100t` → 100 ticks). Formatting helpers for fault status display (ADR-019)
- `inject-fault` CLI subcommand group: `wowsim inject-fault activate FAULT_ID [--delay-ms, --megabytes, --multiplier, --duration, --zone]`, `deactivate FAULT_ID`, `deactivate-all`, `status FAULT_ID`, `list`. Group-level `--host`/`--port` options (default localhost:8081)
- Mock TCP control server fixture in `tests/python/conftest.py`: threading-based, ephemeral port, canned responses by command type, records received requests
- 20 pytest cases for fault trigger covering models (5), duration parsing (5), client commands (4), error handling (3), CLI integration (3)
- Python log parser (`wowsim.log_parser`): parses JSONL telemetry files, filters by type/component/message, computes summaries (counts, time range, duration), and detects anomalies (latency spikes, zone crashes, error bursts, unexpected disconnects) with configurable thresholds
- Pydantic v2 models (`wowsim.models`): `TelemetryEntry`, `LogSummary`, `Anomaly`, `ParseResult` — shared data models for all Python tools (ADR-018)
- `parse-logs` CLI command: `wowsim parse-logs <FILE>` with `--type`, `--component`, `--message` filters, `--anomalies` flag, and `--format json|text` output. Supports stdin via `-`
- Shared test fixtures (`tests/python/conftest.py`): sample JSONL lines, temp log files, anomaly entries — reusable by future Python test modules
- 20 pytest cases for log parser covering model parsing, file/stream parsing, filtering, summary, anomaly detection, and CLI integration
- Control channel (`wow::ControlChannel`): separate TCP server for runtime fault injection commands. Newline-delimited JSON protocol with activate, deactivate, deactivate_all, status, and list commands. Thread-safe command queue (ADR-017) bridges network and game threads — FaultRegistry only touched by game thread
- `wow::CommandQueue`: thread-safe producer/consumer queue mirroring EventQueue pattern (mutex + swap drain). Network thread pushes parsed commands; game thread drains at tick start via `process_pending_commands()`
- Control channel protocol helpers: `fault_mode_to_string()` and `fault_status_to_json()` for JSON serialization of fault status
- Control channel error handling: JSON parse errors responded directly on network thread, missing command field and unknown command errors via queue round-trip
- 22 GoogleTest cases for control channel covering CommandQueue (3), lifecycle (4), connections (3), activate (3), deactivate (3), status/list (3), errors (3)
- Fault injection framework (`wow::Fault`, `wow::FaultRegistry`): abstract base class with `FaultMode` (TICK_SCOPED/AMBIENT), `FaultConfig` (params, target_zone_id, duration_ticks), and `FaultStatus` snapshot. Registry owns faults, handles activation/deactivation, duration-based auto-deactivation, zone targeting, and telemetry emission
- F1 LatencySpikeFault: configurable `sleep_for(delay_ms)` in zone pre-tick hook, default 200ms, simulates processing latency
- F2 SessionCrashFault: removes first entity from zone, fire-once per activation, safe on empty zones, emits telemetry with victim session_id
- F3 EventQueueFloodFault: injects `multiplier * entity_count` synthetic MovementEvents with deterministic positions, default multiplier 10
- F4 MemoryPressureFault: allocates configurable MB in 1MB committed chunks on activation, releases on deactivation, `bytes_allocated()` accessor
- FaultRegistry zone integration: `execute_pre_tick_faults()` fires active tick-scoped faults inside zone exception guard, with zone targeting (0 = all, specific = match). Multi-fault composition supported
- 28 GoogleTest cases for fault injection covering registry lifecycle (11), F1-F4 scenarios (13), and zone integration (4)
- Zone isolation system (`wow::Zone`, `wow::ZoneManager`): self-contained processing units with per-zone entity maps, event queues, and tick pipelines (Movement → SpellCast → Combat). Exception guard wraps each zone's tick in try/catch for crash isolation between zones
- Zone state recovery arc: CRASHED → DEGRADED → ACTIVE on successive successful ticks, visible in telemetry for monitoring dashboard
- Zone session management: `assign_session`/`remove_session`/`transfer_session` with entity state preservation (position, cast, combat) during zone transfers via `unordered_map::extract()`
- ZoneManager event routing: two-stage model (intake → per-zone queues) with session-to-zone lookup. Events for unassigned sessions discarded with telemetry warning
- ZoneManager tick orchestration: sequential tick-all with per-zone error isolation — crashed zone does not affect other zones
- Pre/post tick hooks on Zone for fault injection (forward-compatible with Step 10)
- `ZoneTickResult` and `ZoneManagerTickResult` structs for rich per-tick telemetry
- `ZoneHealth` snapshot struct for monitoring (state, total_ticks, error_count, entity_count, queue_depth, last_tick_duration_ms)
- 30 GoogleTest cases for zone system covering construction (2), entity management (4), event delivery (2), tick pipeline (4), exception guard (4), telemetry (2), zone manager lifecycle (2), session assignment (3), session transfer (2), event routing (3), tick-all and crash isolation (2)
- Combat system (`wow::CombatEvent`, `wow::CombatProcessor`): damage calculation with armor (physical) and resistance (magical) mitigation clamped to 75%, inline death check on zero health, and structured telemetry for damage dealt and entity killed events
- Threat table tracking: damage dealt = threat generated (per ADR-012), additive accumulation across attacks, dead entity cleanup from all threat tables at end of tick
- NPC auto-attack: living NPCs with `base_attack_damage > 0` attack the highest-threat living target each tick, creating the classic boss-fight loop (tank/DPS threat management)
- `EntityType` enum (`PLAYER`, `NPC`) on Entity: distinguishes player-controlled from server-controlled entities, defaults to PLAYER for backward compatibility
- `CombatState` struct on Entity: per-entity health, max_health, armor, resistance, is_alive, base_attack_damage (NPC), and threat_table
- 26 GoogleTest cases for combat system covering event data (3), entity state (3), damage application (3), attack validation (4), kill/death (3), threat table (3), NPC auto-attack (3), and telemetry + integration (4)
- Spell cast system (`wow::SpellCastEvent`, `wow::SpellCastProcessor`): cast initiation with variable cast times, GCD enforcement (1.5s / 30 ticks at 20 Hz), instant casts (cast_time=0), interrupt handling (by event and by movement), and 5-step per-tick processing order (movement cancel → interrupt → advance → cast start → clear flags)
- `CastState` struct on Entity: per-entity spell casting state (`is_casting`, `spell_id`, `cast_ticks_remaining`, `gcd_expires_tick`, `moved_this_tick` cross-phase flag)
- Movement-cancels-cast: `MovementProcessor` sets `moved_this_tick` flag, `SpellCastProcessor` cancels active casts when flag is set (WoW-authentic behavior per ADR-012)
- 24 GoogleTest cases for spell cast system covering data types, entity state, cast initiation, GCD, timer advancement/completion, interrupts, telemetry, and tick integration
- Event system foundation: `GameEvent` base class with `EventType` enum (`MOVEMENT`, `SPELL_CAST`, `COMBAT`), `event_type_to_string()` conversion, polymorphic ownership via `unique_ptr`
- Movement event processing (`wow::MovementEvent`, `wow::MovementProcessor`): position updates on game tick with last-wins semantics for multiple events per session, telemetry on position change and unknown-session warnings
- Thread-safe event queue (`wow::EventQueue`): mutex-protected push/drain with O(1) bulk transfer via swap, bridging network and game threads
- Entity system (`wow::Entity`, `wow::Position`): 3D position tracking keyed by session_id, Euclidean distance calculation, equality operators
- 21 GoogleTest cases for movement system covering Position, GameEvent, MovementEvent, Entity, EventQueue (including concurrent access), MovementProcessor, and tick integration
- TCP game server (`wow::GameServer`) with Asio async accept loop, dedicated network thread, connection registry with atomic count, and RAII start/stop lifecycle. Configurable port (0 for OS-assigned in tests)
- Connection wrapper (`wow::Connection`) bridging TCP sockets and Sessions via `enable_shared_from_this`. Async read loop for disconnect detection, session transition to DESTROYED on client close
- Telemetry events for server start/stop, connection accepted (with session_id and remote_endpoint), and client disconnected
- 23 GoogleTest cases for GameServer covering construction, lifecycle, connection acceptance, disconnect handling, telemetry emission, and edge cases
- Windows build fix: Asio SYSTEM includes, `_WIN32_WINNT=0x0A00`, ws2_32/mswsock linkage

- Player session state machine (`wow::Session`) with 6 states, 7 events, and 10-entry constexpr transition table. Auto-assigned unique session IDs, telemetry on valid/invalid transitions, non-copyable/movable ownership semantics
- 21 GoogleTest cases for session covering construction, all valid transitions, invalid transition rejection, telemetry emission, and string conversion
- Fixed-rate game loop (`wow::GameLoop`) with configurable tick rate (default 20 Hz / 50ms), sleep-for-remainder timing via `steady_clock`, overrun detection, background thread or blocking mode, and per-tick telemetry emission
- 20 GoogleTest cases for game loop covering construction, lifecycle, tick execution, telemetry, overrun detection, and timing accuracy
- Structured JSON telemetry logger (`wow::Logger` singleton) with configurable sinks (file, stdout, custom ostream), ISO 8601 timestamps with millisecond precision, and thread-safe writes
- Logger convenience API: `metric()`, `event()`, `health()`, `error()` wrappers with optional structured `data` payload
- 28 GoogleTest cases for telemetry logger covering schema compliance, type mapping, data handling, multi-line output, file I/O, and concurrent writes
- Server startup/shutdown telemetry events in `main.cpp`
- Cross-platform build support: MSVC (`/W4 /WX`) alongside GCC/Clang (`-Wall -Wextra -Werror`), conditional pthread linking
- Project scaffolding: directory structure, CMake build system, git initialization
- Root `CMakeLists.txt` with FetchContent for Asio, nlohmann/json, GoogleTest
- `src/server/main.cpp` — compilable server stub
- `tests/cpp/CMakeLists.txt` — GoogleTest harness (empty, TDD populates)
- Python tooling package (`tools/wowsim`) with Click CLI and placeholder subcommands
- `tools/pyproject.toml` — installable package with `wowsim` entry point
- Build scripts: `scripts/build.sh`, `scripts/setup_venv.sh`, `scripts/run_all_tests.sh`
- `Dockerfile` — multi-stage build (gcc builder + slim runtime with Python)
- `docker-compose.yml` — server service with game, control, and telemetry ports
- `.github/workflows/ci.yml` — Docker build, C++ tests, Python lint + tests
- `README.md` — quick start, architecture overview, docs links
- Documentation: PRD, ARCHITECTURE, DECISIONS (ADR-001 through ADR-012), CHANGELOG
- `.gitignore` for C++, Python, IDE, and OS artifacts
